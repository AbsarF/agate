#!/usr/bin/env python

from agate.rows import Row
from agate import utils


@utils.allow_tableset_proxy
def homogenize(self, key, compare_values, default_row=None):
    """
    Fills missing rows in a dataset with default values.

    Determines what rows are missing by comparing the values in the given
    column_names with the expected compare_values.

    Values not found in the table will be used to generate new rows with
    the given default_row.

    Default_row should be an array of values or an array-generating
    function. If not specified, the new rows will have `None` in columns
    not given in column_names.

    If it is an array of values, the length should be row length minus
    column_names count and the gap will be filled with the missing values.

    If it is an array-generating function, the function should take an array
    of missing values for each new row and output a full row including those
    values.

    :param key:
        Either a column name or a sequence of such names.
    :param compare_values:
        Either an array of column values if key is a single column name or a
        sequence of arrays of values if key is a sequence of names. It can
        also be a generator that yields one of the two. A row is created for
        each value or list of values not found in the rows of the table.
    :param default_row:
        An array of values or a function to generate new rows. The length of
        the input array should be equal to row length minus column_names
        count. The length of array generated by the function should be the
        row length.
    :returns:
        A new :class:`Table`.
    """
    rows = list(self.rows)

    if not utils.issequence(key):
        key = [key]

    if len(key) == 1:
        if any(not utils.issequence(compare_value) for compare_value in compare_values):
            compare_values = [[compare_value] for compare_value in compare_values]

    column_values = [self.columns.get(name) for name in key]
    column_indexes = [self.column_names.index(name) for name in key]

    column_values = zip(*column_values)
    differences = list(set(map(tuple, compare_values)) - set(column_values))

    for difference in differences:
        if callable(default_row):
            rows.append(Row(default_row(difference), self.column_names))
        else:
            if default_row is not None:
                new_row = default_row
            else:
                new_row = [None] * (len(self.column_names) - len(key))

            for i, d in zip(column_indexes, difference):
                new_row.insert(i, d)

            rows.append(Row(new_row, self.column_names))

    return self._fork(rows, self.column_names, self.column_types)
