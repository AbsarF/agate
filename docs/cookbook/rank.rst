====
Rank
====

There are many ways to rank a sequence of values. agate strives to find a balance between simple, intuitive ranking and flexibility when you need it.

Competition rank
================

The basic rank supported by agate is standard "competition ranking". In this model the values :code:`[3, 4, 4, 5]` would be ranked :code:`[1, 2, 2, 4]`. You can apply competition ranking using the :class:`.Rank` computation:

.. code-block:: python

    new_table = table.compute([
        (agate.Rank('value'), 'rank')
    ])

Rank descending
===============

Descending competition ranking is specified using the :code:`reverse` argument.

.. code-block:: python

    new_table = table.compute([
        (agate.Rank('value', reverse=True), 'rank')
    ])

Rank change
===========

You can compute the change from one rank to another by combining the :class:`.Rank` and class:`.Change` computations:

.. code-block:: python

    new_table = table.compute([
        (agate.Rank('value2014'), 'rank2014'),
        (agate.Rank('value2015'), 'rank2015')
    ])

    new_table2 = new_table.compute([
        (agate.Change('rank2014', 'rank2015'), 'rank_change')
    ])

Percentile rank
===============

"Percentile rank" is a bit of a misnomer. Really, this is the percentile in which each value in a column is located. This column can be computed for your data using the :class:`.PercentileRank` computation:

.. code-block:: Python

    new_table = table.compute([
        (agate.PercentileRank('value'), 'percentile_rank')
    ])

Note that there is no entirely standard method for computing percentiles. The percentiles computed in this manner may not agree with those generated by other programes. See the :class:`.Percentiles` class documentation for implementation details.
